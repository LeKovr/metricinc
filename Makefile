SHELL      = /bin/bash

# -----------------------------------------------------------------------------
# Build config

GO        ?= go

# not supported in BusyBox v1.26.2
LIBS = $(shell find lib -maxdepth 3 -mindepth 1 -name *.go  -printf '%p\n')
CMDS = $(shell find lib -maxdepth 1 -mindepth 1 -type d -printf '%f\n')
SOURCES    = counter/*.go $(LIBS)

# -----------------------------------------------------------------------------
# Docker image config

# application name
PROJECT_NAME  ?= $(shell basename $$PWD)

# docker/compose version
DC_VER ?= 1.14.0

# golang image version
GO_VER ?= latest

DOCKER_BIN ?= docker

# -----------------------------------------------------------------------------
# App config

SERVER_PORT ?= 50051
DB_FILE ?= /data/counter.db

# -----------------------------------------------------------------------------

.PHONY: pb cov-status cov-html mocks build test lint fmt vet vendor

##
## Available targets are:
##

# default: show target list
all:
	@grep -A 1 "^##" Makefile | less

## Generate protobuf
pb:
	$(GO) generate ./lib/proto/...

doc:
	@echo "Open http://localhost:6060/pkg/lekovr/exam"
	@godoc -http=:6060

## Show coverage
cov-status:
	for f in counter lib/* ; do [[ $$f == lib/iface ]] || [[ $$f == lib/proto ]] || \
  { pushd $$f ; $(GO) test -coverprofile=coverage.out ; popd ; } ; done

## Show package coverage in html (make cov-html PKG=counter)
cov-html:
	pushd $(PKG) ; go tool cover -html=coverage.out ; popd

## Generate mocks
mocks: lib/mock_kvstore/mock_kvstore.go

# Install mockgen: go get github.com/golang/mock/mockgen
lib/mock_kvstore/mock_kvstore.go: lib/iface/kvstore/kvstore.go
	mockgen -source=lib/iface/kvstore/kvstore.go > $@

## Build cmds for scratch docker
build-standalone:
	CGO_ENABLED=0 GOOS=linux go build -a ./cmd/server
	CGO_ENABLED=0 GOOS=linux go build -a ./cmd/client

## Build cmds
build: client server

## Build client command
client: cmd/client/*.go $(SOURCES)
	$(GO) build ./cmd/$@

## Build server command
server: cmd/server/*.go $(SOURCES)
	$(GO) build ./cmd/$@

## Run tests
test:
	$(GO) test $$(go list ./... | grep -v /vendor/)

## Run lint
lint:
	golint lib/... | grep -vE "^lib/(mock|proto)" || true
	golint counter/...
	golint cmd/...

## Format go sources
fmt:
	$(GO) fmt ./lib/... && go fmt ./counter/... && go fmt ./cmd/...

## Run vet
vet:
	$(GO) vet ./lib/... && go vet ./counter/... && go vet ./cmd/...

## Install vendor deps
vendor:
	@echo "*** $@:glide ***"
	which glide > /dev/null || curl https://glide.sh/get | sh
	@echo "*** $@ ***"
	glide install

# ------------------------------------------------------------------------------
# Docker part
# ------------------------------------------------------------------------------

build-docker:
	@$(MAKE) -s dc CMD="build --no-cache --force-rm counter"

test-docker: dc-test.out
	diff -c t/$< $< || echo "Test completed"

dc-test.out: t/dc-test.sh
	bash $< > $@

t/dc-test.sh: t/dc-test.sc
	@echo "# This file generated by make $@" > $@; \
  cat $< | \
  while read cmd; do  \
    if [[ "$$cmd" == "restart" ]] ; then \
     echo $(MAKE) -s dc 'CMD="restart counter"' >> $@ ; \
    elif [[ "$$cmd" == "kill" ]] ; then \
     echo $(MAKE) -s dc 'CMD="kill counter"' >> $@ ; \
    elif [[ "$$cmd" == "start" ]] ; then \
     echo DB_FILE=/data.db $(MAKE) -s dc 'CMD="up -d counter"' >> $@ ; \
    elif [[ "$$cmd" == "stop" ]] ; then \
     echo $(MAKE) -s dc 'CMD="rm -f -s counter"' >> $@ ; \
    else \
     echo $(DOCKER_BIN) run --net $(PROJECT_NAME)_default --rm -i counter \
      /client --connect counter:50051 --log_level warn --log_stdout $$cmd '2>&1' >> $@ ; \
    fi \
  done ;\

# ------------------------------------------------------------------------------


# $$PWD используется для того, чтобы текущий каталог был доступен в контейнере по тому же пути
# и относительные тома новых контейнеров могли его использовать
## run docker-compose
dc: docker-compose.yml
	@$(DOCKER_BIN) run --rm  -i \
  -v /var/run/docker.sock:/var/run/docker.sock \
  -v $$PWD:$$PWD \
  -w $$PWD \
  --env=golang_version=$(GO_VER) \
  --env=SERVER_PORT=$(SERVER_PORT) \
  --env=DB_FILE=$(DB_FILE) \
  docker/compose:$(DC_VER) \
  -p $(PROJECT_NAME) \
  $(CMD)

